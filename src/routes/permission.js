// Generated by IcedCoffeeScript 1.6.3-e
(function() {
  var AccessLevel, Attribute, Constants, Cypher, CypherBuilder, CypherLinkUtil, Entity, Link, Logger, RedisKey, Tag, User, getUser, iced, isSuperAwesome, redis, __iced_k, __iced_k_noop, _und;

  iced = require('iced-coffee-script').iced;
  __iced_k = __iced_k_noop = function() {};

  _und = require('underscore');

  redis = require('../models/setup').db.redis;

  Constants = require('../config').Constants;

  AccessLevel = require('../config').AccessLevel;

  Logger = require('../util/logger');

  User = require('../models/user');

  Entity = require('../models/entity');

  Attribute = require('../models/attribute');

  Tag = require('../models/tag');

  Link = require('../models/link');

  Cypher = require('./util/cypher');

  CypherBuilder = Cypher.CypherBuilder;

  CypherLinkUtil = Cypher.CypherLinkUtil;

  RedisKey = require('../config').RedisKey;


  /*
  # Reads http header to get access token
  # Exchange this token for a user unique identifier
  # then return the raw neo4j node of the user
  */

  exports.getUser = getUser = function(req, cb) {
    var accessToken, err, neoUserId, user, ___iced_passed_deferral, __iced_deferrals, __iced_k, _ref,
      _this = this;
    __iced_k = __iced_k_noop;
    ___iced_passed_deferral = iced.findDeferral(arguments);
    accessToken = (_ref = req.headers['x-access-token']) != null ? _ref : "none";
    (function(__iced_k) {
      __iced_deferrals = new iced.Deferrals(__iced_k, {
        parent: ___iced_passed_deferral,
        filename: "permission.coffee",
        funcname: "getUser"
      });
      redis.hget(accessToken, "id", __iced_deferrals.defer({
        assign_fn: (function() {
          return function() {
            err = arguments[0];
            return neoUserId = arguments[1];
          };
        })(),
        lineno: 32
      }));
      __iced_deferrals._fulfill();
    })(function() {
      err = user = null;
      if (!neoUserId) {
        Logger.debug("No such user");
        return cb(null, null);
      }
      Logger.debug("Utility.getUser " + neoUserId);
      (function(__iced_k) {
        __iced_deferrals = new iced.Deferrals(__iced_k, {
          parent: ___iced_passed_deferral,
          filename: "permission.coffee",
          funcname: "getUser"
        });
        User.get(neoUserId, __iced_deferrals.defer({
          assign_fn: (function() {
            return function() {
              err = arguments[0];
              return user = arguments[1];
            };
          })(),
          lineno: 40
        }));
        __iced_deferrals._fulfill();
      })(function() {
        if (err) {
          if (err) {
            return cb(err, null);
          }
        } else {
          return cb(null, user);
        }
      });
    });
  };


  /*
  # Permission Related Stuff
  */

  exports.isSuperAwesome = isSuperAwesome = function(accessToken, cb) {
    return redis.sismember(RedisKey.superToken, accessToken, function(err, res) {
      return cb(err, res);
    });
  };


  /*
  # High level function
  */

  exports.hasPermission = function(user, other, cb) {
    var accessLevel, err, errA, errM, errR, isAdmin, isMember, isPrivate, readonly, ___iced_passed_deferral, __iced_deferrals, __iced_k,
      _this = this;
    __iced_k = __iced_k_noop;
    ___iced_passed_deferral = iced.findDeferral(arguments);
    if (!other) {
      return cb(null, false);
    }
    isPrivate = other._node.data["private"];
    if (!isPrivate && !user) {
      return cb(null, AccessLevel.READONLY);
    } else if (!user) {
      return cb(null, AccessLevel.NO_ACCESS);
    }
    (function(__iced_k) {
      __iced_deferrals = new iced.Deferrals(__iced_k, {
        parent: ___iced_passed_deferral,
        filename: "permission.coffee",
        funcname: "hasPermission"
      });
      CypherLinkUtil.hasLink(user._node, other._node, Constants.REL_READONLY, "all", __iced_deferrals.defer({
        assign_fn: (function() {
          return function() {
            errR = arguments[0];
            return readonly = arguments[1];
          };
        })(),
        lineno: 76
      }));
      CypherLinkUtil.hasLink(user._node, other._node, Constants.REL_MEMBER, "all", __iced_deferrals.defer({
        assign_fn: (function() {
          return function() {
            errM = arguments[0];
            return isMember = arguments[1];
          };
        })(),
        lineno: 81
      }));
      CypherLinkUtil.hasLink(user._node, other._node, Constants.REL_ADMIN, "all", __iced_deferrals.defer({
        assign_fn: (function() {
          return function() {
            errA = arguments[0];
            return isAdmin = arguments[1];
          };
        })(),
        lineno: 86
      }));
      __iced_deferrals._fulfill();
    })(function() {
      err = errR || errM || errA;
      if (err) {
        return cb(err, null);
      }
      accessLevel = 0;
      if (readonly) {
        accessLevel += 1;
      }
      if (isMember) {
        accessLevel += 2;
      }
      if (isAdmin) {
        accessLevel += 3;
      }
      accessLevel = Math.min(accessLevel, 3);
      return cb(null, accessLevel);
    });
  };

  exports.authCurry = function(hasPermission) {
    return function(cb) {
      return function(req, res, next) {
        var augReq, err, errRes, ___iced_passed_deferral, __iced_deferrals, __iced_k,
          _this = this;
        __iced_k = __iced_k_noop;
        ___iced_passed_deferral = iced.findDeferral(arguments);
        (function(__iced_k) {
          __iced_deferrals = new iced.Deferrals(__iced_k, {
            parent: ___iced_passed_deferral,
            filename: "permission.coffee"
          });
          hasPermission(req, res, next, __iced_deferrals.defer({
            assign_fn: (function() {
              return function() {
                err = arguments[0];
                errRes = arguments[1];
                return augReq = arguments[2];
              };
            })(),
            lineno: 105
          }));
          __iced_deferrals._fulfill();
        })(function() {
          if (err) {
            return errRes;
          }
          return cb(augReq, res, next);
        });
      };
    };
  };

}).call(this);
