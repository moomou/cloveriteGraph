// Generated by IcedCoffeeScript 1.6.2d
(function() {
  var Attribute, Constants, Entity, Neo, Response, StdSchema, Tag, Utility, Vote, attrSplit, cypherQueryConstructor, iced, luceneQueryContructor, queryAnalyzer, relSplit, searchFunc, searchableClass, __iced_k, __iced_k_noop, _und;

  iced = require('iced-coffee-script').iced;
  __iced_k = __iced_k_noop = function() {};

  require('source-map-support').install();

  _und = require('underscore');

  Neo = require('../models/neo');

  Entity = require('../models/entity');

  Vote = require('../models/vote');

  Attribute = require('../models/attribute');

  Tag = require('../models/tag');

  StdSchema = require('../models/stdSchema');

  Constants = StdSchema.Constants;

  Response = StdSchema;

  Utility = require('./utility');

  attrSplit = /\bwith\b/;

  relSplit = /\bat\b/;

  searchableClass = {
    entity: Entity,
    attribute: Attribute,
    tag: Tag
  };

  searchFunc = {
    cypher: Neo.query,
    lucene: Neo.search
  };

  queryAnalyzer = function(searchClass, query) {
    var attrQuery, mainQuery, relQuery, remainder, _ref, _ref1;
    mainQuery = attrQuery = relQuery = '';
    console.log("query: " + query);
    _ref = query.split(attrSplit), mainQuery = _ref[0], remainder = _ref[1];
    console.log("mQuery: " + mainQuery);
    if (remainder) {
      _ref1 = remainder.split(relSplit), attrQuery = _ref1[0], remainder = _ref1[1];
    }
    console.log("attrQuery: " + attrQuery);
    console.log("relQuery: " + remainder);
    if (!!mainQuery) {
      mainQuery = mainQuery.trim();
    }
    if (!!attrQuery) {
      attrQuery = attrQuery.split(' ').map(function(item) {
        return item.trim();
      }).filter(function(item) {
        if (!!item) {
          return item;
        }
      });
    }
    if (!!remainder) {
      relQuery = remainder.split(' ').map(function(item) {
        return item.trim();
      }).filter(function(item) {
        if (!!item) {
          return item;
        }
      });
    }
    return cypherQueryConstructor(searchClass, mainQuery, attrQuery, relQuery);
  };

  cypherQueryConstructor = function(searchClass, name, attrMatches, relMatches) {
    var attrMatchQ, attrName, endQ, ind, relMatchQ, relName, startNodeQ, _i, _j, _len, _len1,
      _this = this;
    if (name == null) {
      name = '';
    }
    if (attrMatches == null) {
      attrMatches = [];
    }
    if (relMatches == null) {
      relMatches = [];
    }
    console.log("name: " + name);
    console.log("attrMatches: " + attrMatches);
    console.log("relMatches: " + relMatches);
    name = name.replace(' ', encodeURIComponent(' '));
    attrMatches = _und.map(attrMatches, function(attrMatch) {
      return attrMatch.replace(' ', encodeURIComponent(' '));
    });
    relMatches = _und.map(relMatches, function(relMatch) {
      return relMatch.replace(' ', encodeURIComponent(' '));
    });
    startNodeQ = "START n=node:__indexName__('name:" + name + "~0.65')";
    endQ = 'RETURN DISTINCT n AS result;';
    attrMatchQ = [];
    relMatchQ = [];
    for (ind = _i = 0, _len = attrMatches.length; _i < _len; ind = ++_i) {
      attrName = attrMatches[ind];
      attrMatchQ.push("MATCH (n)<-[:_ATTRIBUTE]-(attribute) WHERE attribute.name=~'(?i)" + attrName + "'");
    }
    attrMatchQ = attrMatchQ.join(' WITH n as n ');
    for (ind = _j = 0, _len1 = relMatches.length; _j < _len1; ind = ++_j) {
      relName = relMatches[ind];
      relMatchQ.push("MATCH (n)-[r]->(related) WHERE related.name=~'(?i)" + relName + "'");
    }
    relMatchQ = relMatchQ.join(' WITH n as n ');
    switch (searchClass) {
      case Tag:
        return [startNodeQ, "MATCH (n)-[:_TAG]->(entity) WITH entity as n", attrMatchQ, "WITH n as n", relMatchQ, endQ].join('\n');
      case Attribute:
        return [startNodeQ, "MATCH (n)-[:_ATTRIBUTE]->(entity) WITH entity as n", attrMatchQ, "WITH n as n", relMatchQ, endQ].join('\n');
      default:
        return [startNodeQ, attrMatchQ, "WITH n as n", relMatchQ, endQ].join('\n');
    }
  };

  luceneQueryContructor = function(query) {
    var key, queryString, val, _i, _len;
    queryString = [];
    for (val = _i = 0, _len = query.length; _i < _len; val = ++_i) {
      key = query[val];
      queryString.push("" + key + ":" + val);
    }
    return queryString.join("AND");
  };

  exports.searchHandler = function(req, res, next) {
    var attrBlobs, blobResults, entity, entitySerialized, err, identified, ind, indX, indY, obj, query, result, results, searchClass, searchClasses, ___iced_passed_deferral, __iced_deferrals, __iced_k,
      _this = this;
    __iced_k = __iced_k_noop;
    ___iced_passed_deferral = iced.findDeferral(arguments);
    if (!req.query['q']) {
      return res.json({});
    }
    if (req.params.type) {
      searchClasses = [searchableClass[req.params.type]];
    } else {
      searchClasses = _und.values(searchableClass);
    }
    results = [];
    (function(__iced_k) {
      var _i, _len;
      __iced_deferrals = new iced.Deferrals(__iced_k, {
        parent: ___iced_passed_deferral,
        filename: "search.coffee",
        funcname: "searchHandler"
      });
      for (ind = _i = 0, _len = searchClasses.length; _i < _len; ind = ++_i) {
        searchClass = searchClasses[ind];
        query = queryAnalyzer(searchClass, req.query['q']);
        console.log(query);
        Neo.query(searchClass, query.replace('__indexName__', searchClass.INDEX_NAME), {}, __iced_deferrals.defer({
          assign_fn: (function(__slot_1, __slot_2) {
            return function() {
              err = arguments[0];
              return __slot_1[__slot_2] = arguments[1];
            };
          })(results, ind),
          lineno: 118
        }));
      }
      __iced_deferrals._fulfill();
    })(function() {
      blobResults = [];
      identified = {};
      (function(__iced_k) {
        var _i, _len, _ref, _results, _while;
        _ref = results;
        _len = _ref.length;
        indX = 0;
        _results = [];
        _while = function(__iced_k) {
          var _break, _continue, _next;
          _break = function() {
            return __iced_k(_results);
          };
          _continue = function() {
            return iced.trampoline(function() {
              ++indX;
              return _while(__iced_k);
            });
          };
          _next = function(__iced_next_arg) {
            _results.push(__iced_next_arg);
            return _continue();
          };
          if (!(indX < _len)) {
            return _break();
          } else {
            result = _ref[indX];
            (function(__iced_k) {
              var _j, _len1, _ref1, _results1, _while;
              _ref1 = result;
              _len1 = _ref1.length;
              indY = 0;
              _results1 = [];
              _while = function(__iced_k) {
                var _break, _continue, _next;
                _break = function() {
                  return __iced_k(_results1);
                };
                _continue = function() {
                  return iced.trampoline(function() {
                    ++indY;
                    return _while(__iced_k);
                  });
                };
                _next = function(__iced_next_arg) {
                  _results1.push(__iced_next_arg);
                  return _continue();
                };
                if (!(indY < _len1)) {
                  return _break();
                } else {
                  obj = _ref1[indY];
                  entity = new Entity(obj.result);
                  (function(__iced_k) {
                    __iced_deferrals = new iced.Deferrals(__iced_k, {
                      parent: ___iced_passed_deferral,
                      filename: "search.coffee",
                      funcname: "searchHandler"
                    });
                    Utility.getEntityAttributes(entity, __iced_deferrals.defer({
                      assign_fn: (function() {
                        return function() {
                          return attrBlobs = arguments[0];
                        };
                      })(),
                      lineno: 128
                    }));
                    __iced_deferrals._fulfill();
                  })(function() {
                    entitySerialized = entity.serialize(null, {
                      attributes: attrBlobs
                    });
                    return _next(!identified[entitySerialized.id] ? (blobResults.push(entitySerialized), identified[entitySerialized.id] = true) : void 0);
                  });
                }
              };
              _while(__iced_k);
            })(_next);
          }
        };
        _while(__iced_k);
      })(function() {
        return res.json(blobResults);
      });
    });
  };

}).call(this);

/*
//@ sourceMappingURL=search.map
*/
